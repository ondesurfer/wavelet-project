<!DOCTYPE html>
<meta charset="utf-8">
<style>
	.chart div {
		font: 10px sans-serif;
		background-color: steelblue;
		text-align: right;
		padding: 3px;
		margin: 1px;
		color: white;
	}

</style>
<div class="chart"></div>
plotSplineIntervallWavelets
<script src="../js/ext_libs/d3.js"></script>
<script src="../js/libs/math2.js"></script>
<script src="../js/libs/mask.js"></script>
<script src="../js/libs/matrixOperations.js"></script>
<script src="../js/htmlElementFunctions2.js"></script>
<script src="../js/libs/pointEvaluation.js"></script>
<script src="../js/libs/gauss2.js"></script>
<!-- load http://maurizzzio.github.io/function-plot/ -->
<script src="../js/ext_libs/function-plot.js"></script>
<script src="../js/ext_libs/numeric-1.2.6.js"></script>

<body>
	<div id="plot1"> </div>
	<div id="plot2"> </div>
	<div id="plot3"> </div>
</body>

<script>
	/** Computes the node grid to constuct the BSplines for an intervall as primal scaling-functions as described by M.Primbs. See p.50.
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{int} grid grid which later will be used to construct the B-Splines.
 */
	function buildNodeGridForBSpline(d,j){
		var grid = new Array();
		for(var k=0;k<d;k++){
			grid.push(0);
		}
		for(var k=1; k<Math.pow(2,j); k++){
			grid.push(Math.pow(2,-j)*k);
		}
		for(var k=0; k<d; k++){
			grid.push(1);
		}
		console.log("Das Gitter fuer die BSplines:", grid);
		return grid;
	}
	
/** Computes the node grid as [0,0...,0,1,2,...]. It can be used 
 * to build BSplines for j=0 with just left side boarder-functions and
 * to calculate B_1,B_2 Matrices. For more details see [Pr] p.56
 *
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 * 
 *   @return{int} grid grid which later will be used to construct the B-Splines.
 */
	function buildNodeGridForBSpline2(d){
		var grid = new Array();
		for(var k=0;k<d;k++){
			grid.push(0);
		}
		for(var k=1; k<2*d+1; k++){
			grid.push(k);
		}
		return grid;
	}

	/** evaluates B-Spline N_{d,k} with the knots t at the point x.
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} t grid of B-Spline
 * 	@param{int} k number of B-Spline (counted from left to right started at k=0)
 *  @param{double} x x-value where the BSpline will be evaluated
 * 
 *   @return{double} y y-value of BSpline at x
 */	
	function evaluateBSplineInPointX(d,t,k,x){
		if(d==1){
			if(t[k-1]<=x&& x<t[k]){
				return 1;
			}else{
				return 0;
			}			
		}
		else{
			var y=0;
			var diff=t[k+d-2]-t[k-1]; 
			if(diff>0){
				y=(x-t[k-1])*evaluateBSplineInPointX(d-1,t,k,x)/diff;
			}
			diff=t[k+d-1]-t[k];
			if(diff>0){
				y=y+(t[k+d-1]-x)*evaluateBSplineInPointX(d-1,t,k+1,x)/diff;
			}
		}
		return y;
	}
	
	/**evaluates a IntervallWavelet which complets Psi=Phi*Mj1
	* @param{int} j is the level of the searched wavelet
	* @param{int}k is the number of the wavelet (usually counted from left to right)
	* @param{object[]} scf is an vector of the scaling-functions phi
	* @param{double[][]} Mj1 is the matrix
	* @param{double} x is the point where the value of the wavelet is searched
	* 
	* @return{double} y y-value of the wavelet in x
	*/
	function evaluateSIWaveletInX(j,k,scf,Mj1,x){
		var PsiInX=0;
		
		if(scf.length!=Mj1.length){
			console.log("scf-length",scf.length,"Mj1-length",Mj1.length);
			console.log("Matrix-vector dimension does not fit.");
			return null;
		}
		for(var i=0; i<scf.length; i++){
			PsiInX=PsiInX + Mj1[i][k]*scf[i].eval(x); 
		}
		return PsiInX;
	}
	
/** Computes the primal scaling functions as described by M.Primbs. See p.50.
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all scaling-function as an array of objects. 
 * 						Each object has the 'eval' function to evaluate the scaling-function in x
 */
	function buildPrimalPrimbsScf(j,d){
		var m = Math.pow(2,j)+d-1; //Number of scaling-functions
		var nodes = buildNodeGridForBSpline(d,j);
		var scf = new Array(m);
		//Object of a primal Primbs scaling-function
		function Obj( prop1, prop2, prop3 ) { 
    				return { 
       				 	d1 : prop1,
       				 	nodes1 : prop2,
       				 	k1 : prop3, 
        				eval : function(x){ return evaluateBSplineInPointX(this.d1,this.nodes1,this.k1+1,x); }, 
   					 }; 			
			};
			
		for(var k=0; k<m; k++){	
			scf[k] = new Obj(d,nodes,k);
		}
		console.log(scf);
		return scf;
	}
	
	/** Computes the dual scaling functions for B-Splines as described by M.Primbs. See p.50. and CDF
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual functions
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all scaling-function as an array of objects. 
 * 						Each object has the 'values' function to calculate values of the scaling-function in
 */
	function buildMiddleDualPrimbsScf(d,d_tilde,j){
		var m = Math.pow(2,j)-d-2*d_tilde+3; //see p. 61
		console.log("m",m);
		var dmscf=new Array(m);
		//Object of a middle dual scaling function (from Primbs)
		function Obj3(d, d_tilde, k,j) { 
    				return { 
    					d1 : d ,
    					d_tilde1 : d_tilde,
       				 	k1 : k, 
       				 	j1 :j,
        				values : function(){ return evaluateMiddleDualPrimbsScf(this.d1,this.d_tilde1,this.k1,this.j1);}, 
   					 }; 			
			};
			
		for(var k=0; k<m; k++){		
			dmscf[k] = new Obj3(d,d_tilde,k,j);
		}
		return dmscf;
	}
	
/** Computes values of dual scaling of B-Splines as described by M.Primbs. See p.50. and CDF
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual functions
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{double[]} returns all calculated values 
 */
	function evaluateMiddleDualPrimbsScf(d,d_tilde,k,j){
		var coef =  genDualBSplineCoeffs(d, d_tilde);
		var values = iterativePointEvaluation2(coef[0],0, 8, 0);
		//Translatierung um k (k=1...d+d_tilde-2)?
		console.log(values);
		 for(var l=0; l<values.length; l++){
			values[l][0]=values[l][0]+k;
		}
		console.log(values);
		//Skalierung um 2 hoch -j
		for(var l=0; l<values.length; l++){
			values[l][0]=Math.pow(2,-j)*values[l][0];
		}
		console.log(values);
		return values;	
	}
			
/** Computes the dual left border scaling functions without border conditions as described by M.Primbs. See p.71.
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all scaling-function as an array of objects. 
 * 					Each object has the 'eval' function to evaluate the scaling-function in x
 */
	function buildLeftDualPrimbsScfI(d,d_tilde,j){
		var m = d_tilde; //Number of border-functions see p.71
		var dscf = new Array(m);
		function Obj2(d, d_tilde, phiTilde, k,j) { 
    				return { 
    					d1 : d ,
    					d_tilde1 : d_tilde,
       				 	phiTilde1 : phiTilde,
       				 	k1 : k, 
       				 	j1 :j,
        				eval : function(x){ return evaluateLeftDualPrimbsScfI(this.d1,this.d_tilde1,this.phiTilde1,this.k1+1,Math.pow(2,j)*x); }, 
   					 }; 			
			};
		//calculate values of dual B-Spline function phiTilde - wenn wir nicht phiTildeuebergeben wuerden muessten wir jedes Mal alles rechnen.
		var coef =  genDualBSplineCoeffs(d, d_tilde);
		var phiTilde = iterativePointEvaluation2(coef[0], coef[1], 8, 0);
		console.log("phiTilde",phiTilde);
		for(var k=0; k<m; k++){		
			dscf[k] = new Obj2(d,d_tilde,phiTilde,k,j);
		}	
		return dscf;	
	}
	

/** Evaluates Left border functions without border conditions as described by M.Primbs. See p.71.
 *	Values of one dual function phiTilde already must be given in an aequidistant grid.
 *  (last modification: 31.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual B-Spline
 *   @param{double[]} phiTilde values of the dual B-Spline which is used to construct the other ones
 * 	 @param{integer} k number of the searched border function, counted from left to right
 * 	 @param{double} x value, which function value is searched.
 * 
 *   @return{double} y  function value of the border function
 */
	function evaluateLeftDualPrimbsScfI(d, d_tilde, phiTilde, k,x) {
	//calculate left and right support of dual B-Spline border function
		var l_1=-Math.floor(d/2)-d_tilde+1;
		var l_2=Math.ceil(d/2)+d_tilde-1;
		
		//grid steps of phiTilde
		var delta = phiTilde[1][0]-phiTilde[0][0];
		var y=0;		
			if(x<0){
				return 0;
			}
			else{
				for(var n=k; n<l_2-l_1-1;n++){			
					y += nchoosek(n,k) * phi_tilde2(phiTilde, x + n + l_1 + 1);//hier richtiger Index...
				}
			}
		return y;
	}

	/** Searches an y-value for a x-value. The function values must be given in an equidistant grid.
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{double[]} values	values of the function (must be given in an aequidistant grid)
 *   @param{double} x 			value for which y is searched
 * 
 *   @return{double} y function-value of x
 */
	function phi_tilde2(values,x){
		var delta = values[1][0]-values[0][0];
		var index = Math.round((x-values[0][0])/delta);
		if(index<values.length){
			return values[Math.round(index)][1];
		}
		else{
			return 0;
		}
	}
	
//Not finished!!! Problem is to calculate m[n][k]
/** Computes the dual left border scaling functions without border conditions as described by M.Primbs. See p.71.
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all left border scaling-function as an array of objects. 
 * 					Each object has the 'eval' function to evaluate the scaling-function in x
 */
	function buildLeftDualPrimbsScfII(d,d_tilde,j){
		var m = d-2; //Number of border-functions - see s.84
		var dscf = new Array(m);
		function Obj4(d, d_tilde, phiL, k,j) { 
    				return { 
    					d1 : d ,
    					d_tilde1 : d_tilde,
       				 	phiL1 : phiL,
       				 	k1 : k, 
       				 	j1 :j,
        				eval : function(x){ 
        						var y=0;
        						for(var n=k+1; n<d+2*k-1; n++){
        							y+=M[n][k]*phiL[n-1].eval(2*x);
        						}
        						return y;}, 
   					 }; 			
			};
		//build first part of left dual functions which also are necessary to 
		//to construct the rest of the left scaling functions
		dscf.push(buildLeftDualPrimbsScfI(d,d_tilde,j));
		for(var k=d-2; k>0; k--){		
			dscf[k-1] = new Obj4(d,d_tilde,dscf,k,j);
		}	
		return dscf;	
	}
 
 	/**
	*	Setup Mj1 transform matrix with respect to nonperiodic spline wavelet bases on [0,1].
	*	(last modification: 3.1.17 Andreas)
	*   
	*  @param{Integer}   d				primal (spline) order, d>=2
	*  @param{Integer}   d_tilde		dual order, d_tilde>=2
	*  @param{Integer}   s0				primal boundary condition order at x=0
	*  @param{Integer}   s1				primal boundary condition order at x=1
	*  @param{Integer}   j				level in which to transform
	*
	*  @return{Array}    M				transformation matrix
	*/
	function Mj1(d,d_tilde,s0,s1,j){
		
		if(d != 2){
			console.log("d != 2 not supported");
		}
		
		if(d_tilde != 2){
			console.log("d_tilde != 2 not supported");
		}
		
		if(s0<0 || s0>1){
	    	console.log("at the moment, we only support 0<=s0<=1!");
		}
	
		if(s1<0 || s1>1){
		    console.log("at the moment, we only support 0<=s1<=1!");
		}
	
		if(s0+s1<=1){
		    if(j<2){
		        console.log("j too small, j>=2 for these boundary conditions!")
		    }
		}else{
		    if(j<3){
		        console.log("j too small, j>=3 for these boundary conditions!")
		    }
		}
		
		var M = zeros(Math.pow(2,j+1)+1-(s0+s1), Math.pow(2,j));
		
		if(s0==0){
			setBlock(M, [[-3/4], [9/16], [-1/8], [-1/16]], 0, 0);
		}else{
			setBlock(M, [[5/8], [-3/4], [-1/4], [1/4], [1/8]], 0, 0);
	    }
		for(var k = 2; k < Math.pow(2,j); k++){
			setBlock(M, [[-1/8], [-1/4], [3/4], [-1/4], [-1/8]],
		    		2-s0+2*(k - 2) - 1, k - 1);
		}
		
		if(s1==0){
			setBlock(M, [[-1/16], [-1/8], [9/16], [-3/4]], 
					M.length - 3 - 1, M[0].length - 1);
		}else{
			setBlock(M, [[1/8], [1/4], [-1/4], [-3/4], [5/8]],
					M.length - 4 - 1 , M[0].length - 1);
		}
		
		M = numeric.mul(M, 1/Math.sqrt(2));
		return M;
	}
	
	/**
	*	Setup Mj1t transform matrix with respect to nonperiodic spline wavelet bases on [0,1].
	*	(last modification: 3.1.17 Andreas)
	*   
	*  @param{Integer}   d				primal (spline) order, d>=2
	*  @param{Integer}   d_tilde		dual order, d_tilde>=2
	*  @param{Integer}   s0				primal boundary condition order at x=0
	*  @param{Integer}   s1				primal boundary condition order at x=1
	*  @param{Integer}   j				level in which to transform
	*
	*  @return{Array}    M				transformation matrix
	*/
	function Mj1t(d,d_tilde,s0,s1,j){
		
		if(d != 2){
			console.log("d != 2 not supported");
		}
		
		if(d_tilde != 2){
			console.log("d_tilde != 2 not supported");
		}
		
		if(s0<0 || s0>1){
	    	console.log("at the moment, we only support 0<=s0<=1!");
		}
	
		if(s1<0 || s1>1){
		    console.log("at the moment, we only support 0<=s1<=1!");
		}
	
		if(s0+s1<=1){
		    if(j<2){
		        console.log("j too small, j>=2 for these boundary conditions!")
		    }
		}else{
		    if(j<3){
		        console.log("j too small, j>=3 for these boundary conditions!")
		    }
		}
		
		var M = zeros(Math.pow(2,j+1)+1-(s0+s1), Math.pow(2,j));
		
		if(s0==0){
			setBlock(M, [[-1],[2],[-1]], 0, 0);
		}else{
			setBlock(M, [[2],[-1]], 0, 0);
	    }
		for(var k = 2; k < Math.pow(2,j); k++){
			setBlock(M, [[-1],[2],[-1]],
		    		3-s0+2*(k - 2) - 1, k - 1);
		}
		
		if(s1==0){
			setBlock(M, [[-1], [2], [-1]], 
					M.length - 2 - 1, M[0].length - 1);
		}else{
			setBlock(M, [[-1],[2]],
					M.length - 1 - 1 , M[0].length - 1);
		}
		
		M = numeric.mul(M, 1/Math.sqrt(2));
		return M;
	}
	
/** Evaluates a function, given as an object with the function 'eval', in a grid
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{double[]} grid grid,where the function shall be evaluated
 *   @param{object} obj function, given as an object, which shall be evaluated
 * 
 *   @return{double[][]} points points of the function as [[x0,f(x0)],[x1,f(y1)],...]
 */
	function evaluateObjectInGrid(obj,grid){
		var points = new Array(grid.length);	
		for(var j=0; j<grid.length; j++){
			points[j]=[grid[j], obj.eval(grid[j])];
		}
		return points;
	}
	
	
	//Plotten der dualen mittleren Skalierungsfunktionen
	if(false){
		var d=2;
		var d_tilde=4;
		var j=3;
		var dscf=buildMiddleDualPrimbsScf(d,d_tilde,j);
		var values1=dscf[0].values();
		var values2=dscf[0].values();
		var values3=dscf[0].values();
	}
	
	//Plotten der dualen linken SkalierungsfunktionenI
	if(false){
		var d=3;
		var d_tilde=5;
		var j=2;
		var dscf=buildLeftDualPrimbsScfI(d,d_tilde,j);
		var grid = makeGrid(0,8,8024);
		var values1 = evaluateObjectInGrid(dscf[0],grid);
		var values2 = evaluateObjectInGrid(dscf[1],grid);
		var values3 = evaluateObjectInGrid(dscf[2],grid);
	}
	
	
	//Plotten der primalen Skalierungsfunktionen
	if(true){
		var d=3;
		var j=3;
		var scf=buildPrimalPrimbsScf(j,d);
		var grid = makeGrid(0,1,100);
		console.log(grid);
		var values1 = evaluateObjectInGrid(scf[0],grid);
		var values2 = evaluateObjectInGrid(scf[1],grid);
		var values3 = evaluateObjectInGrid(scf[2],grid);
	}
	
	//Plotten der k-ten Wavelets (dafuer muessen vorher die primalen Skalierungsfunktionen berechnet worden sein!)
	if(true){
		//var k = 0;
		var d = 2;
		var j = 3;
		var scf=buildPrimalPrimbsScf(j,d);
		j = 2;
		var d_tilde = 2;
		
		//Matrix fuer d=2,d_tilde=2,j=2
		/* var Mj1_1 = [[-0.5303,0,0,0],
		             [0.3977, -0.0884, 0, 0],
		             [-0.0884, -0.1768, 0,0],
		             [-0.0442, 0.5303, -0.0884,  0],
	         		 [0, -0.1768, -0.1768, 0],
	         		 [0, -0.0884, 0.5303, -0.0442],
	         		 [0, 0, -0.1768, -0.0884],
	         		 [0, 0, -0.0884, 0.3977],
	         		 [0, 0, 0,  -0.5303]];
		 */
		// boundary conditions
		var s0 = 0;
		var s1 = 0;
		
		var Mj1_1 =  Mj1(d,d_tilde,s0,s1,j);
	
		var params1 = [j,0,scf,Mj1_1];
		var params2 = [j,1,scf,Mj1_1];
		var params3 = [j,2,scf,Mj1_1];
		var values1 = evaluateFunctionInGrid(evaluateSIWaveletInX,params1,0,1,1000);
		var values2 = evaluateFunctionInGrid(evaluateSIWaveletInX,params2,0,1,1000);
		var values3 = evaluateFunctionInGrid(evaluateSIWaveletInX,params3,0,1,1000);
	}

	function makeGrid(start,end,count){
		var x=new Array(count);
		var step=(end-start)/(x.length-1);
		for (var i=0; i < x.length; i++) {
		  x[i]=start+i*step;
		};
		return x;
	}
	
	// test of a general evaluation in grid function
	/*  Evaluate a function on grid points specified by [start, end, count]
		(last modification: 17.10.16 Andreas)
	*/
	function evaluateFunctionInGrid(funct,params,start,end,count){
		var x = makeGrid(start,end,count);
		var points = new Array(x.length);
		
		var params2 = deepCopyVector(params);
		params2.push(0); 
		
		for(var i=0; i< x.length; i++){
			params2[params2.length -1 ] = x[i];
			points[i]=[x[i], funct.apply(this, params2)];
		}
		return points;
	}
	
	plotInst1 = 0;
	plotInst2 = 0;
	plotInst3 = 0;
		
	function evaluateRthDerivOfBSplineInPointX(d,t,k,r,x){
		//return 0 if the order of derivate is bigger than the spline-order
		if(d<r+1){
			return 0;
		}
		
		//if just the point-evaluation (without derivation) is searched
		if(r==0){
			return evaluateBSplineInPointX(d,t,k,x);
		}
		
		else{
			var y=0;
			var diff=t[k+d-2]-t[k-1];
			if(diff>0){
				y=(d-1)*evaluateRthDerivOfBSplineInPointX(d-1,t,k,r-1,x)/diff;
			}
			diff=t[k+d-1]-t[k];
			if(diff>0){
				y=y-(d-1)*evaluateRthDerivOfBSplineInPointX(d-1,t,k+1,r-1,x)/diff;
			}
		}
		return y;
	}

	// a general function to create a plot-instance
	function makePlotInst(target, values){
		try{ 
			plotInst = functionPlot({
			target : target,
			data : [{
				points : values,
				fnType : 'points',
				graphType : 'polyline',
			}]
		});
	
			//return the wavelet plot as object
			return plotInst;
				
			}catch (err) {
				console.log(err);
				alert(err);
			}
	}
	//a general function to create a plot-instance with 3 functions in one plot
	function makePlotInst3(target, valuesI, valuesII, valuesIII){
		try{ 
			plotInst = functionPlot({
			target : target,
			data : [{
				points : valuesI,
				fnType : 'points',
				graphType : 'polyline',
			},{
				points : valuesII,
				fnType : 'points',
				graphType : 'polyline',
			},{
				points : valuesIII,
				fnType : 'points',
				graphType : 'polyline',
			}]
		});
	
			//returns the wavelet plot as object
			return plotInst;
				
			}catch (err) {
				console.log(err);
				alert(err);
			}
	}
	
	//build three plots with values1, values2 and values3
	/* makePlotInst('#plot1', values1);		
	makePlotInst('#plot2', values2);		
	makePlotInst('#plot3', values3); */		
	
	makePlotInst3('#plot1', values1, values2, values3);
	
	/**
	*	Test of Mj1 in the case d = 2, d_tilde = 2, j = 3
	*	without boundary conditions
	*/
/* 	var d = 2;
	var d_tilde = 2;
	var j = 2;
	var s0 = 0;
	var s1 = 0;
	var A = Mj1(d,d_tilde,s0,s1,j);
	printMatrix(A); */
	
</script>
