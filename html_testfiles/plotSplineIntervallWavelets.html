<!DOCTYPE html>
<meta charset="utf-8">
<style>
	.chart div {
		font: 10px sans-serif;
		background-color: steelblue;
		text-align: right;
		padding: 3px;
		margin: 1px;
		color: white;
	}

</style>
<div class="chart"></div>
plotSplineIntervallWavelets
<script src="../js/ext_libs/d3.js"></script>
<script src="../js/libs/math2.js"></script>
<script src="../js/libs/mask.js"></script>
<script src="../js/libs/matrixOperations.js"></script>
<script src="../js/htmlElementFunctions2.js"></script>
<script src="../js/libs/pointEvaluation.js"></script>
<script src="../js/libs/gauss2.js"></script>
<!-- load http://maurizzzio.github.io/function-plot/ -->
<script src="../js/ext_libs/function-plot.js"></script>
<script src="../js/ext_libs/numeric-1.2.6.js"></script>

<body>
	<div id="plot1"> </div>
	<div id="plot2"> </div>
	<div id="plot3"> </div>
</body>

<script>
	/** Computes the node grid to constuct the BSplines for an intervall as primal scaling-functions as described by M.Primbs. See p.50.
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{int} grid grid which later will be used to construct the B-Splines.
 */
	function buildNodeGridForBSpline(d,j){
		var grid = new Array();
		for(var k=0;k<d;k++){
			grid.push(0);
		}
		for(var k=1; k<Math.pow(2,j); k++){
			grid.push(Math.pow(2,-j)*k);
		}
		for(var k=0; k<d; k++){
			grid.push(1);
		}
		console.log("Das Gitter fuer die BSplines:", grid);
		return grid;
	}
	
/** Computes the node grid as [0,0...,0,1,2,...]. It can be used 
 * to build BSplines for j=0 with just left side boarder-functions and
 * to calculate B_1,B_2 Matrices. For more details see [Pr] p.56
 *
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 * 
 *   @return{int} grid grid which later will be used to construct the B-Splines.
 */
	function buildNodeGridForBSpline2(d){
		var grid = new Array();
		for(var k=0;k<d;k++){
			grid.push(0);
		}
		for(var k=1; k<2*d+1; k++){
			grid.push(k);
		}
		return grid;
	}

	/** evaluates B-Spline N_{d,k} with the knots t at the point x.
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} t grid of B-Spline
 * 	@param{int} k number of B-Spline (counted from left to right started at k=0)
 *  @param{double} x x-value where the BSpline will be evaluated
 * 
 *   @return{double} y y-value of BSpline at x
 */	
	function evaluateBSplineInPointX(d,t,k,x){
		if(d==1){
			if(t[k-1]<=x&& x<t[k]){
				return 1;
			}else{
				return 0;
			}			
		}
		else{
			var y=0;
			var diff=t[k+d-2]-t[k-1]; 
			if(diff>0){
				y=(x-t[k-1])*evaluateBSplineInPointX(d-1,t,k,x)/diff;
			}
			diff=t[k+d-1]-t[k];
			if(diff>0){
				y=y+(t[k+d-1]-x)*evaluateBSplineInPointX(d-1,t,k+1,x)/diff;
			}
		}
		return y;
	}
	
	/**evaluates a IntervallWavelet which complets Psi=Phi*Mj1
	* @param{int} j is the level of the searched wavelet
	* @param{int}k is the number of the wavelet (usually counted from left to right)
	* @param{object[]} scf is an vector of the scaling-functions phi
	* @param{double[][]} Mj1 is the matrix
	* @param{double} x is the point where the value of the wavelet is searched
	* 
	* @return{double} y y-value of the wavelet in x
	*/
	function evaluateSIWaveletInX(j,k,scf,Mj1,x){
		var PsiInX=0;
		
		if(scf.length!=Mj1.length){
			console.log("scf-length",scf.length,"Mj1-length",Mj1.length);
			console.log("Matrix-vector dimension does not fit.");
			return null;
		}
		for(var i=0; i<scf.length; i++){
			PsiInX=PsiInX + Mj1[i][k]*scf[i].eval(x); 
		}
		return PsiInX;
	}
	
/** Computes the primal scaling functions as described by M.Primbs. See p.50.
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all scaling-function as an array of objects. 
 * 						Each object has the 'eval' function to evaluate the scaling-function in x
 */
	function buildPrimalPrimbsScf(j,d){
		var m = Math.pow(2,j)+d-1; //Number of scaling-functions
		var nodes = buildNodeGridForBSpline(d,j);
		var scf = new Array(m);
		//Object of a primal Primbs scaling-function
		function Obj( prop1, prop2, prop3 ) { 
    				return { 
       				 	d1 : prop1,
       				 	nodes1 : prop2,
       				 	k1 : prop3, 
        				eval : function(x){ return evaluateBSplineInPointX(this.d1,this.nodes1,this.k1+1,x); }, 
   					 }; 			
			};
			
		for(var k=0; k<m; k++){	
			scf[k] = new Obj(d,nodes,k);
		}
		console.log(scf);
		return scf;
	}
	
	/** Computes the dual scaling functions for B-Splines as described by M.Primbs. See p.50. and CDF
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual functions
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all scaling-function as an array of objects. 
 * 						Each object has the 'values' function to calculate values of the scaling-function in
 */
	function buildMiddleDualPrimbsScf(d,d_tilde,j){
		var m = Math.pow(2,j)-d-2*d_tilde+3; //see p. 61
		console.log("m",m);
		var dmscf=new Array(m);
		//Object of a middle dual scaling function (from Primbs)
		function Obj3(d, d_tilde, k,j) { 
    				return { 
    					d1 : d ,
    					d_tilde1 : d_tilde,
       				 	k1 : k, 
       				 	j1 :j,
        				values : function(){ return evaluateMiddleDualPrimbsScf(this.d1,this.d_tilde1,this.k1,this.j1);}, 
   					 }; 			
			};
			
		for(var k=0; k<m; k++){		
			dmscf[k] = new Obj3(d,d_tilde,k,j);
		}
		return dmscf;
	}
	
/** Computes values of dual scaling of B-Splines as described by M.Primbs. See p.50. and CDF
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual functions
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{double[]} returns all calculated values 
 */
	function evaluateMiddleDualPrimbsScf(d,d_tilde,k,j){
		var coef =  genDualBSplineCoeffs(d, d_tilde);
		var values = iterativePointEvaluation2(coef[0],0, 8, 0);
		//Translatierung um k (k=1...d+d_tilde-2)?
		console.log(values);
		 for(var l=0; l<values.length; l++){
			values[l][0]=values[l][0]+k;
		}
		console.log(values);
		//Skalierung um 2 hoch -j
		for(var l=0; l<values.length; l++){
			values[l][0]=Math.pow(2,-j)*values[l][0];
		}
		console.log(values);
		return values;	
	}
			
/** Computes the dual left border scaling functions without border conditions as described by M.Primbs. See p.71.
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all scaling-function as an array of objects. 
 * 					Each object has the 'eval' function to evaluate the scaling-function in x
 */
	function buildLeftDualPrimbsScfI(d,d_tilde,j){
		var m = d_tilde; //Number of border-functions see p.71
		var dscf = new Array(m);
		function Obj2(d, d_tilde, phiTilde, k,j) { 
    				return { 
    					d1 : d ,
    					d_tilde1 : d_tilde,
       				 	phiTilde1 : phiTilde,
       				 	k1 : k, 
       				 	j1 :j,
       				 	//vermutlich waere values besser
       				 	//values: function(){return valuesOfLeftDualPrimbsScfI(...)}  - eine Methode findet sich bereits in plotLeftCDFdualFunction.html
        				eval : function(x){ return evaluateLeftDualPrimbsScfI(this.d1,this.d_tilde1,this.phiTilde1,this.k1+1,Math.pow(2,j)*x); }, 
   					 }; 			
			};
		//calculate values of dual B-Spline function phiTilde - wenn wir nicht phiTildeuebergeben wuerden muessten wir jedes Mal alles rechnen.
		var coef =  genDualBSplineCoeffs(d, d_tilde);
		var phiTilde = iterativePointEvaluation2(coef[0], coef[1], 8, 0);
		console.log("phiTilde",phiTilde);
		for(var k=0; k<m; k++){		
			dscf[k] = new Obj2(d,d_tilde,phiTilde,k,j);
		}	
		return dscf;	
	}
	

/** Evaluates Left border functions without border conditions as described by M.Primbs. See p.71.
 *	Values of one dual function phiTilde already must be given in an aequidistant grid.
 *  (last modification: 31.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual B-Spline
 *   @param{double[]} phiTilde values of the dual B-Spline which is used to construct the other ones
 * 	 @param{integer} k number of the searched border function, counted from left to right
 * 	 @param{double} x value, which function value is searched.
 * 
 *   @return{double} y  function value of the border function
 */
	function evaluateLeftDualPrimbsScfI(d, d_tilde, phiTilde, k,x) {
	//calculate left and right support of dual B-Spline border function
		var l_1=-Math.floor(d/2)-d_tilde+1;
		var l_2=Math.ceil(d/2)+d_tilde-1;
		
		//grid steps of phiTilde
		var y=0;		
			if(x<0){
				return 0;
			}
			else{
				for(var n=k; n<l_2-l_1-1;n++){			
					y += nchoosek(n,k) * phi_tilde2(phiTilde, x + n + l_1 + 1);//hier richtiger Index...
				}
			}
		return y;
	}

	/** Searches an y-value for a x-value. The function values must be given in an equidistant grid.
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{double[]} values	values of the function (must be given in an aequidistant grid)
 *   @param{double} x 			value for which y is searched
 * 
 *   @return{double} y function-value of x
 */
	function phi_tilde2(values,x){
		var delta = values[1][0]-values[0][0];
		var index = Math.round((x-values[0][0])/delta);
		if(index<values.length){
			return values[Math.round(index)][1];
		}
		else{
			return 0;
		}
	}
	
//Not finished!!! Problem is to calculate m[n][k]
/** Computes the dual left border scaling functions without border conditions as described by M.Primbs. See p.71.
 *  (last modification: 27.12.16 Simon)
 * 
 *   @param{int} d order of B-Spline
 *   @param{int} d_tilde order of dual B-Spline
 *   @param{int} j level for which the B-Splines are wanted
 * 
 *   @return{object[]} scf returns all left border scaling-function as an array of objects. 
 * 					Each object has the 'eval' function to evaluate the scaling-function in x
 */
	function buildLeftDualPrimbsScfII(d,d_tilde,j){
		var m = d-2; //Number of border-functions - see p.84
		var dscf = new Array(m);
		function Obj4(d, d_tilde, phiL, k,j,M) { 
    				return { 
    					d1 : d ,
    					d_tilde1 : d_tilde,
       				 	phiL1 : phiL,
       				 	k1 : k, 
       				 	j1 :j,
       				 	
        				eval : function(x){ 
        						var y=0;
        						for(var n=k+1; n<d+2*k-1; n++){
        							y+=M[n][k]*phiL[n-1].eval(2*x);
        						}
        						return y;}, 
   					 }; 			
			};
	
		//M fuer d=3,dTilde=5
		var M=[[0,0,0,0,0,0],[7,0.0625,0,0,0,0],[-1,0.1875,0.125,0,0,0],[0.166666667,0.125,0.4375,0.25,0,0],[0,-0.0625,0.4375,1,0.5,0],[0,-0.0234375,0,1.3125,2.25,1],[0,0.05859375,-0.14453125,0.58203125,1.73046875,1.01953125],[0,-0.01953125,-0.00390625,0.00390625,1.30859375,0.94140625],[0,0,0.05859375,-0.203125,0.78515625,0.9453125],[0,0,-0.01953125,0.015625,-0.01171875,1.3203125],[0,0,0,0.05859375,-0.26171875,1.046875],[0,0,0,-0.01953125,0.03515625,-0.046875],[0,0,0,0,0.05859375,-0.3203125],[0,0,0,0,-0.01953125,0.0546875],[0,0,0,0,0,0.05859375],[0,0,0,0,0,-0.01953125]];
		//build first part of left dual functions which also are necessary to 
		//to construct the rest of the left scaling functions
		var dscf=buildLeftDualPrimbsScfI(d,d_tilde,j);
		
		for(var k=d-2; k>0; k--){		
			dscf.unshift(new Obj4(d,d_tilde,dscf,k,j,M));
			console.log('dscf',dscf);
		}	
		return dscf;	
	}
 
 	/**
	*	Setup Mj1 transform matrix with respect to nonperiodic spline wavelet bases on [0,1].
	*	(last modification: 3.1.17 Andreas)
	*   
	*  @param{Integer}   d				primal (spline) order, d>=2
	*  @param{Integer}   d_tilde		dual order, d_tilde>=2
	*  @param{Integer}   s0				primal boundary condition order at x=0
	*  @param{Integer}   s1				primal boundary condition order at x=1
	*  @param{Integer}   j				level in which to transform
	*
	*  @return{Array}    M				transformation matrix
	*/
	function Mj1(d,d_tilde,s0,s1,j){
		
		if(d != 2){
			console.log("d != 2 not supported");
		}
		
		if(d_tilde != 2){
			console.log("d_tilde != 2 not supported");
		}
		
		if(s0<0 || s0>1){
	    	console.log("at the moment, we only support 0<=s0<=1!");
		}
	
		if(s1<0 || s1>1){
		    console.log("at the moment, we only support 0<=s1<=1!");
		}
	
		if(s0+s1<=1){
		    if(j<2){
		        console.log("j too small, j>=2 for these boundary conditions!")
		    }
		}else{
		    if(j<3){
		        console.log("j too small, j>=3 for these boundary conditions!")
		    }
		}
		
		var M = zeros(Math.pow(2,j+1)+1-(s0+s1), Math.pow(2,j));
		
		if(s0==0){
			setBlock(M, [[-3/4], [9/16], [-1/8], [-1/16]], 0, 0);
		}else{
			setBlock(M, [[5/8], [-3/4], [-1/4], [1/4], [1/8]], 0, 0);
	    }
		for(var k = 2; k < Math.pow(2,j); k++){
			setBlock(M, [[-1/8], [-1/4], [3/4], [-1/4], [-1/8]],
		    		2-s0+2*(k - 2) - 1, k - 1);
		}
		
		if(s1==0){
			setBlock(M, [[-1/16], [-1/8], [9/16], [-3/4]], 
					M.length - 3 - 1, M[0].length - 1);
		}else{
			setBlock(M, [[1/8], [1/4], [-1/4], [-3/4], [5/8]],
					M.length - 4 - 1 , M[0].length - 1);
		}
		
		M = numeric.mul(M, 1/Math.sqrt(2));
		return M;
	}
	
	/**
	*	Setup Mj1t transform matrix with respect to nonperiodic spline wavelet bases on [0,1].
	*	(last modification: 3.1.17 Andreas)
	*   
	*  @param{Integer}   d				primal (spline) order, d>=2
	*  @param{Integer}   d_tilde		dual order, d_tilde>=2
	*  @param{Integer}   s0				primal boundary condition order at x=0
	*  @param{Integer}   s1				primal boundary condition order at x=1
	*  @param{Integer}   j				level in which to transform
	*
	*  @return{Array}    M				transformation matrix
	*/
	function Mj1t(d,d_tilde,s0,s1,j){
		
		if(d != 2){
			console.log("d != 2 not supported");
		}
		
		if(d_tilde != 2){
			console.log("d_tilde != 2 not supported");
		}
		
		if(s0<0 || s0>1){
	    	console.log("at the moment, we only support 0<=s0<=1!");
		}
	
		if(s1<0 || s1>1){
		    console.log("at the moment, we only support 0<=s1<=1!");
		}
	
		if(s0+s1<=1){
		    if(j<2){
		        console.log("j too small, j>=2 for these boundary conditions!")
		    }
		}else{
		    if(j<3){
		        console.log("j too small, j>=3 for these boundary conditions!")
		    }
		}
		
		var M = zeros(Math.pow(2,j+1)+1-(s0+s1), Math.pow(2,j));
		
		if(s0==0){
			setBlock(M, [[-1],[2],[-1]], 0, 0);
		}else{
			setBlock(M, [[2],[-1]], 0, 0);
	    }
		for(var k = 2; k < Math.pow(2,j); k++){
			setBlock(M, [[-1],[2],[-1]],
		    		3-s0+2*(k - 2) - 1, k - 1);
		}
		
		if(s1==0){
			setBlock(M, [[-1], [2], [-1]], 
					M.length - 2 - 1, M[0].length - 1);
		}else{
			setBlock(M, [[-1],[2]],
					M.length - 1 - 1 , M[0].length - 1);
		}
		
		M = numeric.mul(M, 1/Math.sqrt(2));
		return M;
	}
	
/** Evaluates a function, given as an object with the function 'eval', in a grid
 *  (last modification: 22.12.16 Simon)
 * 
 *   @param{double[]} grid grid,where the function shall be evaluated
 *   @param{object} obj function, given as an object, which shall be evaluated
 * 
 *   @return{double[][]} points points of the function as [[x0,f(x0)],[x1,f(y1)],...]
 */
	function evaluateObjectInGrid(obj,grid){
		var points = new Array(grid.length);	
		for(var j=0; j<grid.length; j++){
			points[j]=[grid[j], obj.eval(grid[j])];
		}
		return points;
	}
	
	
	//Plotten der dualen mittleren Skalierungsfunktionen
	if(false){
		var d=2;
		var d_tilde=4;
		var j=3;
		var dscf=buildMiddleDualPrimbsScf(d,d_tilde,j);
		var values1=dscf[0].values();
		var values2=dscf[0].values();
		var values3=dscf[0].values();
	}
	
	//Plotten der dualen linken SkalierungsfunktionenI
	if(false){
		var d=3;
		var d_tilde=5;
		var j=2;
		var dscf=buildLeftDualPrimbsScfI(d,d_tilde,j);
		var grid = makeGrid(0,8,8024);
		var values1 = evaluateObjectInGrid(dscf[0],grid);
		var values2 = evaluateObjectInGrid(dscf[1],grid);
		var values3 = evaluateObjectInGrid(dscf[2],grid);
	}
	
	//Plotten der dualen linken SkalierungsfunktionenII
	if(false){
		var d=3;
		var d_tilde=5;
		var j=2;
		var dscf=buildLeftDualPrimbsScfII(d,d_tilde,j);
		var grid = makeGrid(0,8,8024);
		var values1 = evaluateObjectInGrid(dscf[0],grid);
		var values2 = evaluateObjectInGrid(dscf[1],grid);
		var values3 = evaluateObjectInGrid(dscf[2],grid);
	}
	
	
	//Plotten der primalen Skalierungsfunktionen
	if(false){
		var d=3;
		var j=3;
		var scf=buildPrimalPrimbsScf(j,d);
		var grid = makeGrid(0,1,100);
		console.log(grid);
		var values1 = evaluateObjectInGrid(scf[0],grid);
		var values2 = evaluateObjectInGrid(scf[1],grid);
		var values3 = evaluateObjectInGrid(scf[2],grid);
	}
	
	//Plotten der k-ten Wavelets (dafuer muessen vorher die primalen Skalierungsfunktionen berechnet worden sein!)
	if(true){
		var d = 2;
		var d_tilde = 2;
		//smallest j which is possible - later it will be saved in the database
		var j = 3;
		var scf=buildPrimalPrimbsScf(j,d);
		
		
		//Matrix fuer d=2,d_tilde=2,j=2
		var Mj1_2_2_2 = [[-0.5303,0,0,0],
		             [0.3977, -0.0884, 0, 0],
		             [-0.0884, -0.1768, 0,0],
		             [-0.0442, 0.5303, -0.0884,  0],
	         		 [0, -0.1768, -0.1768, 0],
	         		 [0, -0.0884, 0.5303, -0.0442],
	         		 [0, 0, -0.1768, -0.0884],
	         		 [0, 0, -0.0884, 0.3977],
	         		 [0, 0, 0,  -0.5303]]; 
	     var Mj1_2_2_2b =[[1.06066017177982,0,0,0],[-0.795495128834866,0.176776695296637,0,0],[0.176776695296637,0.353553390593274,0,0],[0.0883883476483185,-1.06066017177982,0.176776695296637,0],[0,0.353553390593274,0.353553390593274,0],[0,0.176776695296637,-1.06066017177982,0.0883883476483185],[0,0,0.353553390593274,0.176776695296637],[0,0,0.176776695296637,-0.795495128834866],[0,0,0,1.06066017177982]];
	     //Matrix fuer d=3, d_tilde=5, j=5
	     var Mj1_3_5_5 = [[-0.265,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [0.419,0.087,-0.0483,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [-0.308,-0.0102,-0.00725,-0.00691,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [0.0538,-0.378,0.172,-0.0207,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [0.146,0.548,0.00483,0.0262,-0.00691,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [-0.0326,-0.0587,-0.508,0.134,-0.0207,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [-0.0804,-0.241,0.447,-0.0359,0.0262,-0.00691,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [0.0019,0.000207,0.0404,-0.483,0.134,-0.0207,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [0.0306,0.0859,-0.116,0.483,-0.0359,0.0262,-0.00691,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [0.0055,0.0157,-0.0235,0.0359,-0.483,0.134,-0.0207,-0,-0,-0,-0,-0,-0,-0,-0,-0],
	     [-0.00527,-0.0145,0.0173,-0.134,0.483,-0.0359,0.0262,-0.00691,-0,-0,-0,-0,-0,-0,-0,-0],
	     [-0.00176,-0.00483,0.00575,-0.0262,0.0359,-0.483,0.134,-0.0207,-0,-0,-0,-0,-0,-0,-0,-0],
	     [-0,-0,-0,0.0207,-0.134,0.483,-0.0359,0.0262,0.00691,-0,-0,-0,-0,-0,-0,-0],
	     [-0,-0,-0,0.00691,-0.0262,0.0359,-0.483,0.134,0.0207,-0,-0,-0,-0,-0,-0,-0],
	     [-0,-0,-0,-0,0.0207,-0.134,0.483,-0.0359,-0.0262,0.00691,-0,-0,-0,-0,-0,-0],
	     [-0,-0,-0,-0,0.00691,-0.0262,0.0359,-0.483,-0.134,0.0207,-0,-0,-0,-0,-0,-0],
	     [-0,-0,-0,-0,-0,0.0207,-0.134,0.483,0.0359,-0.0262,0.00691,-0,-0,-0,-0,-0],
	     [-0,-0,-0,-0,-0,0.00691,-0.0262,0.0359,0.483,-0.134,0.0207,-0,-0,-0,-0,-0],
	     [-0,-0,-0,-0,-0,-0,0.0207,-0.134,-0.483,0.0359,-0.0262,0.00691,-0,-0,-0,-0],
	     [-0,-0,-0,-0,-0,-0,0.00691,-0.0262,-0.0359,0.483,-0.134,0.0207,-0,-0,-0,-0],
	     [-0,-0,-0,-0,-0,-0,-0,0.0207,0.134,-0.483,0.0359,-0.0262,0.00691,-0,-0,-0],
	     [-0,-0,-0,-0,-0,-0,-0,0.00691,0.0262,-0.0359,0.483,-0.134,0.0207,-0,-0,-0],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0.0207,0.134,-0.483,0.0359,-0.0262,0.00575,-0.00483,-0.00176],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0.00691,0.0262,-0.0359,0.483,-0.134,0.0173,-0.0145,-0.00527],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.0207,0.134,-0.483,0.0359,-0.0235,0.0157,0.0055],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.00691,0.0262,-0.0359,0.483,-0.116,0.0859,0.0306],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.0207,0.134,-0.483,0.0404,0.000207,0.0019],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.00691,0.0262,-0.0359,0.447,-0.241,-0.0804],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.0207,0.134,-0.508,-0.0587,-0.0326],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.00691,0.0262,0.00483,0.548,0.146],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.0207,0.172,-0.378,0.0538],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.00691,-0.00725,-0.0102,-0.308],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.0483,0.087,0.419],
	     [-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0.265]];      
	     
	     var Mj1_3_5_5b=[[0.530330086,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-0.837134327,-0.174014559,0.0966747552,0,0,0,0,0,0,0,0,0,0,0,0,0],[0.615750288,0.0203016986,0.0145012133,0.0138106793,0,0,0,0,0,0,0,0,0,0,0,0],[-0.107512686,0.756963334,-0.343195381,0.041432038,0,0,0,0,0,0,0,0,0,0,0,0],[-0.291053161,-1.09629172,-0.00966747552,-0.0524805814,0.0138106793,0,0,0,0,0,0,0,0,0,0,0],[0.0651288619,0.117390774,1.01508493,-0.267927179,0.041432038,0,0,0,0,0,0,0,0,0,0,0],[0.160877151,0.482683242,-0.894241486,0.0718155325,-0.0524805814,0.0138106793,0,0,0,0,0,0,0,0,0,0],[-0.00380829482,-0.000414320378,-0.080792474,0.966747552,-0.267927179,0.041432038,0,0,0,0,0,0,0,0,0,0],[-0.0611030489,-0.171804851,0.232940125,-0.966747552,0.0718155325,-0.0524805814,0.0138106793,0,0,0,0,0,0,0,0,0],[-0.0110071114,-0.0314883488,0.0469563097,-0.0718155325,0.966747552,-0.267927179,0.041432038,0,0,0,0,0,0,0,0,0],[0.010530643,0.0290024266,-0.0345266983,0.267927179,-0.966747552,0.0718155325,-0.0524805814,0.0138106793,0,0,0,0,0,0,0,0],[0.00351021433,0.00966747552,-0.0115088994,0.0524805814,-0.0718155325,0.966747552,-0.267927179,0.041432038,0,0,0,0,0,0,0,0],[0,0,0,-0.041432038,0.267927179,-0.966747552,0.0718155325,-0.0524805814,-0.0138106793,0,0,0,0,0,0,0],[0,0,0,-0.0138106793,0.0524805814,-0.0718155325,0.966747552,-0.267927179,-0.041432038,0,0,0,0,0,0,0],[0,0,0,0,-0.041432038,0.267927179,-0.966747552,0.0718155325,0.0524805814,-0.0138106793,0,0,0,0,0,0],[0,0,0,0,-0.0138106793,0.0524805814,-0.0718155325,0.966747552,0.267927179,-0.041432038,0,0,0,0,0,0],[0,0,0,0,0,-0.041432038,0.267927179,-0.966747552,-0.0718155325,0.0524805814,-0.0138106793,0,0,0,0,0],[0,0,0,0,0,-0.0138106793,0.0524805814,-0.0718155325,-0.966747552,0.267927179,-0.041432038,0,0,0,0,0],[0,0,0,0,0,0,-0.041432038,0.267927179,0.966747552,-0.0718155325,0.0524805814,-0.0138106793,0,0,0,0],[0,0,0,0,0,0,-0.0138106793,0.0524805814,0.0718155325,-0.966747552,0.267927179,-0.041432038,0,0,0,0],[0,0,0,0,0,0,0,-0.041432038,-0.267927179,0.966747552,-0.0718155325,0.0524805814,-0.0138106793,0,0,0],[0,0,0,0,0,0,0,-0.0138106793,-0.0524805814,0.0718155325,-0.966747552,0.267927179,-0.041432038,0,0,0],[0,0,0,0,0,0,0,0,0.041432038,-0.267927179,0.966747552,-0.0718155325,0.0524805814,-0.0115088994,0.00966747552,0.00351021433],[0,0,0,0,0,0,0,0,0.0138106793,-0.0524805814,0.0718155325,-0.966747552,0.267927179,-0.0345266983,0.0290024266,0.010530643],[0,0,0,0,0,0,0,0,0,0.041432038,-0.267927179,0.966747552,-0.0718155325,0.0469563097,-0.0314883488,-0.0110071114],[0,0,0,0,0,0,0,0,0,0.0138106793,-0.0524805814,0.0718155325,-0.966747552,0.232940125,-0.171804851,-0.0611030489],[0,0,0,0,0,0,0,0,0,0,0.041432038,-0.267927179,0.966747552,-0.080792474,-0.000414320378,-0.00380829482],[0,0,0,0,0,0,0,0,0,0,0.0138106793,-0.0524805814,0.0718155325,-0.894241486,0.482683242,0.160877151],[0,0,0,0,0,0,0,0,0,0,0,0.041432038,-0.267927179,1.01508493,0.117390774,0.0651288619],[0,0,0,0,0,0,0,0,0,0,0,0.0138106793,-0.0524805814,-0.00966747552,-1.09629172,-0.291053161],[0,0,0,0,0,0,0,0,0,0,0,0,0.041432038,-0.343195381,0.756963334,-0.107512686],[0,0,0,0,0,0,0,0,0,0,0,0,0.0138106793,0.0145012133,0.0203016986,0.615750288],[0,0,0,0,0,0,0,0,0,0,0,0,0,0.0966747552,-0.174014559,-0.837134327],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.530330086]];  		 
		 //var Mj1b=scalarMatrixProduct(Mj1a,-2);
		 //printMatrix(Mj1b);
		 var Mj1_2_4_4=[[-0.386699021,0.165728152,-0,-0,-0,-0,-0,-0],
		 [0.40281148,-0.0621480569,0.0165728152,-0,-0,-0,-0,-0],
		 [-0.221891581,-0.290024266,0.0331456304,-0,-0,-0,-0,-0],
		 [-0.0731966004,0.476468437,-0.0883883476,0.0165728152,-0,-0,-0,-0],
		 [0.0754983803,-0.171252424,-0.209922326,0.0331456304,-0,-0,-0,-0],
		 [0.0308438505,-0.0731966004,0.497184456,-0.0883883476,0.0165728152,-0,-0,-0],
		 [-0.0138106793,0.0248592228,-0.209922326,-0.209922326,0.0331456304,-0,-0,-0],
		 [-0.00690533966,0.0124296114,-0.0883883476,0.497184456,-0.0883883476,0.0165728152,-0,-0],
		 [-0,-0,0.0331456304,-0.209922326,-0.209922326,0.0331456304,-0,-0],
		 [-0,-0,0.0165728152,-0.0883883476,0.497184456,-0.0883883476,0.0124296114,-0.00690533966],
		 [-0,-0,-0,0.0331456304,-0.209922326,-0.209922326,0.0248592228,-0.0138106793],
		 [-0,-0,-0,0.0165728152,-0.0883883476,0.497184456,-0.0731966004,0.0308438505],
		 [-0,-0,-0,-0,0.0331456304,-0.209922326,-0.171252424,0.0754983803],
		 [-0,-0,-0,-0,0.0165728152,-0.0883883476,0.476468437,-0.0731966004],
		 [-0,-0,-0,-0,-0,0.0331456304,-0.290024266,-0.221891581],
		 [-0,-0,-0,-0,-0,0.0165728152,-0.0621480569,0.40281148],
		 [-0,-0,-0,-0,-0,-0,0.165728152,-0.386699021]];
		 
		
		//var Mj1_1 =  Mj1(d,d_tilde,s0,s1,j);
		var Mj1_1=Mj1_2_2_2b;
		
		var params1 = [j,0,scf,Mj1_1];
		var params2 = [j,1,scf,Mj1_1];
		var params3 = [j,2,scf,Mj1_1];
		var values1 = evaluateFunctionInGrid(evaluateSIWaveletInX,params1,0,1,1000);
		var values2 = evaluateFunctionInGrid(evaluateSIWaveletInX,params2,0,1,1000);
		var values3 = evaluateFunctionInGrid(evaluateSIWaveletInX,params3,0,1,1000);
	}
	
	function scalarMatrixProduct(A,k){
		var result = createArray(A.length,A[0].length);
		for(var l=0; l<A.length; l++){
			for(var c=0; c<A[0].length; c++){
				result[l][c]=A[l][c]*k;
			}	
		}
	}
		 

	function makeGrid(start,end,count){
		var x=new Array(count);
		var step=(end-start)/(x.length-1);
		for (var i=0; i < x.length; i++) {
		  x[i]=start+i*step;
		};
		return x;
	}
	
	// test of a general evaluation in grid function
	/*  Evaluate a function on grid points specified by [start, end, count]
		(last modification: 17.10.16 Andreas)
	*/
	function evaluateFunctionInGrid(funct,params,start,end,count){
		var x = makeGrid(start,end,count);
		var points = new Array(x.length);
		
		var params2 = deepCopyVector(params);
		params2.push(0); 
		
		for(var i=0; i< x.length; i++){
			params2[params2.length -1 ] = x[i];
			points[i]=[x[i], funct.apply(this, params2)];
		}
		return points;
	}
	
	plotInst1 = 0;
	plotInst2 = 0;
	plotInst3 = 0;
		
	function evaluateRthDerivOfBSplineInPointX(d,t,k,r,x){
		//return 0 if the order of derivate is bigger than the spline-order
		if(d<r+1){
			return 0;
		}
		
		//if just the point-evaluation (without derivation) is searched
		if(r==0){
			return evaluateBSplineInPointX(d,t,k,x);
		}
		
		else{
			var y=0;
			var diff=t[k+d-2]-t[k-1];
			if(diff>0){
				y=(d-1)*evaluateRthDerivOfBSplineInPointX(d-1,t,k,r-1,x)/diff;
			}
			diff=t[k+d-1]-t[k];
			if(diff>0){
				y=y-(d-1)*evaluateRthDerivOfBSplineInPointX(d-1,t,k+1,r-1,x)/diff;
			}
		}
		return y;
	}

	// a general function to create a plot-instance
	function makePlotInst(target, values){
		try{ 
			plotInst = functionPlot({
			target : target,
			data : [{
				points : values,
				fnType : 'points',
				graphType : 'polyline',
			}]
		});
	
			//return the wavelet plot as object
			return plotInst;
				
			}catch (err) {
				console.log(err);
				alert(err);
			}
	}
	//a general function to create a plot-instance with 3 functions in one plot
	function makePlotInst3(target, valuesI, valuesII, valuesIII){
		try{ 
			plotInst = functionPlot({
			target : target,
			data : [{
				points : valuesI,
				fnType : 'points',
				graphType : 'polyline',
			},{
				points : valuesII,
				fnType : 'points',
				graphType : 'polyline',
			},{
				points : valuesIII,
				fnType : 'points',
				graphType : 'polyline',
			}]
		});
	
			//returns the wavelet plot as object
			return plotInst;
				
			}catch (err) {
				console.log(err);
				alert(err);
			}
	}
	
	//build three plots with values1, values2 and values3
	makePlotInst('#plot1', values1);		
	makePlotInst('#plot2', values2);		
	makePlotInst('#plot3', values3);	
	
	//makePlotInst3('#plot1', values1, values2, values3);
	
	/**
	*	Test of Mj1 in the case d = 2, d_tilde = 2, j = 3
	*	without boundary conditions
	*/
/* 	var d = 2;
	var d_tilde = 2;
	var j = 2;
	var s0 = 0;
	var s1 = 0;
	var A = Mj1(d,d_tilde,s0,s1,j);
	printMatrix(A); */
	
</script>
