<!DOCTYPE html>
<meta charset="utf-8">
<style>
	.chart div {
		font: 10px sans-serif;
		background-color: steelblue;
		text-align: right;
		padding: 3px;
		margin: 1px;
		color: white;
	}

</style>
<div class="chart"></div>
test-File
<!--<script src="//d3js.org/d3.v3.min.js"></script>\\-->
<script src="../js/ext_libs/d3.js"></script>
<script src="../js/libs/math2.js"></script>
<script src="../js/libs/mask.js"></script>
<script src="../js/libs/matrixOperations.js"></script>
<script src="../js/htmlElementFunctions2.js"></script>
<script src="../js/libs/pointEvaluation.js"></script>
<script src="../js/libs/gauss2.js"></script>

<!-- load http://maurizzzio.github.io/function-plot/ -->
<script src="../js/ext_libs/function-plot.js"></script>
<script src="../js/ext_libs/numeric-1.2.6.js"></script>

<body>
	<div id="plot1"> </div>
	<div id="plot2"> </div>
	<div id="plot3"> </div>
</body>

<script>	
	//evaluates B-Spline N_{d,k} with the knots t at the point x
	function evaluateBSplineInPointX(d,t,k,x){
		if(d==1){
			if(t[k-1]<=x&& x<t[k]){
				return 1;
			}else{
				return 0;
			}
			
		}
		else{
			var y=0;
			var diff=t[k+d-2]-t[k-1]; 
			if(diff>0){
				y=(x-t[k-1])*evaluateBSplineInPointX(d-1,t,k,x)/diff;
			}
			diff=t[k+d-1]-t[k];
			if(diff>0){
				y=y+(t[k+d-1]-x)*evaluateBSplineInPointX(d-1,t,k+1,x)/diff;
			}
		}
		return y;
	}
	
	function makeGrid(start,end,count){
		var x=new Array(count);
		var step=(end-start)/(x.length-1);
		for (var i=0; i < x.length; i++) {
		  x[i]=start+i*step;
		};
		return x;
	}
	
	function evaluateRthDerivOfBSplineInPointX(d,t,k,r,x){
		//return 0 if the order of derivate is bigger than the spline-order
		if(d<r+1){
			return 0;
		}
		
		//if just the point-evaluation (without derivation) is searched
		if(r==0){
			return evaluateBSplineInPointX(d,t,k,x);
		}
		
		else{
			var y=0;
			var diff=t[k+d-2]-t[k-1];
			if(diff>0){
				y=(d-1)*evaluateRthDerivOfBSplineInPointX(d-1,t,k,r-1,x)/diff;
			}
			diff=t[k+d-1]-t[k];
			if(diff>0){
				y=y-(d-1)*evaluateRthDerivOfBSplineInPointX(d-1,t,k+1,r-1,x)/diff;
			}
		}
		return y;
	}

	
	// test of a general evaluation in grid function
	/*  Evaluate a function on grid points specified by [start, end, count]
		(last modification: 17.10.16 Andreas)
	*/
	function evaluateFunctionInGrid(funct,params,start,end,count){
		var x = makeGrid(start,end,count);
		var points = new Array(x.length);
		
		var params2 = deepCopyVector(params);
		params2.push(0); // it would be better to have a deep copy
		
		for(var i=0; i< x.length; i++){
			params2[params2.length -1 ] = x[i];
			points[i]=[x[i], funct.apply(this, params2)];
			//console.log(funct.apply(this, params));
			//console.log(params);
			
		}
		return points;
	} 
	

function buildPlot(target) {
	try {
		var plotInst = functionPlot({
			target : target,
			data : [ {
				points : [  ],
				fnType : 'points',
				graphType : 'polyline',
			} ]
		});
		
		function bigPlot( plot1, allValues1 ) {
   			return { 
       			 	plot : plot1,
       			 	allValues : allValues1,
   			 }; 			
		};
				
		var bigPlotObj = new bigPlot(plotInst,[]);
		
		function zoomFilter() {
			var xDomain = this.options.xDomain;
			var newPoints = filter(xDomain[0], xDomain[1],bigPlotObj.allValues, 1000);
			if (newPoints == undefined) {
				// console.log("No more detailled points available. Please zoom out.");
				alert("No more detailled points available. Please zoom out.");
			} else {
				this.options.data[0].points = newPoints;
			}
		} 
		console.log(bigPlotObj);	
		bigPlotObj.plot.on("during:draw", zoomFilter);
		return bigPlotObj;
			
	} catch (err) {
		console.log(err);
		alert(err);
	}
}
	
	
var plot=buildPlot('#plot1');		
console.log(plot);

//params:[order, knots, ?? , derivative]
	var params1 = [3,[0,1,2,3],1,0];
	values1 = evaluateFunctionInGrid(evaluateRthDerivOfBSplineInPointX,params1,-1,5,1000);
	console.log("values1",values1);
	plot.allValues=values1;
	plot.plot.draw();
	
	
	
// a general function to create a plot-instances
function makePlotInst(target, values){
		try{ 
			plotInst = functionPlot({
			target : target,
			data : [{
				points : values,
				fnType : 'points',
				graphType : 'polyline',
			}]
		});
	
			//return the wavelet plot as object
			return plotInst;
				
			}catch (err) {
				console.log(err);
				alert(err);
			}
	}
	
	
	
	
	
	/** This method searches only a few nessecary values of a function in a
 *  equally spaced grid.  This makes the plot a lot faster.
 *
 *	(last modification: 25.7.16 Simon)
 *	@param{Array} 	allValues 		Input of all the values, which should be
 * 										filtered.
 * 	@param{float} 	leftXvalue 		left border of the function plot.
 *  @param{float}	rightXvalue		right border of the function plot.
 *  @param{int} 	wantedNumOfValues  wanted Number of values in the interval
 * 										leftXvalue..rightXvalue. (A gridwidth is calculated 
 * 										which complies that 'wantedNumOfValues' of values are choosen 
 * 										from the interval leftXvalue..rightXvalue. 
 * 										If 'allValues' does not contain the interval, less values than 
 * 										'wantedNumOfValues' are choosen, satisfying the calculated gridwidth. )
 *  
 * 	@return{Array} 	values  
 */

function filter(leftXvalue, rightXvalue, allValues, wantedNumOfValues){
	//if there is no value in the allValues-Array
	if(allValues.length==0){
		//console.log("kein Wert enthalten");
		return allValues;
	}	
	//console.log("test");
	//the smallest x-value contained in 'allValues'
	var funcXleft = allValues[0][0];
	var funcXright = allValues[allValues.length-1][0];
	
	//if there is no value in the window
	if(leftXvalue>funcXright||rightXvalue<funcXleft){
		return[];
	}
	
	//distance between x-values in allValues
	var gridDist=allValues[1][0]-allValues[0][0];
	
	//distance nessecary to get 'wantedNumOfValues' 
	var wishedDist=(rightXvalue-leftXvalue)/wantedNumOfValues;
	//step
	var step=wishedDist/gridDist;
	//console.log("step", step);
	if (step<0.4){
		console.log("Aufloesung zu niedrig");
		return undefined;
	}else{
		step=Math.floor(step);
	}		
	if(step==0){step=1;}	
	
	//Indices of first and last necessary x-Value from 'allValues'
	var startIndex;
	var endIndex;
	
	if(leftXvalue<=funcXleft){
		startIndex=0;
	}
	else{
		 startIndex=Math.floor((leftXvalue-funcXleft)/gridDist);
	}
	if(rightXvalue>=funcXright){
		endIndex=allValues.length-1;
	}
	else{
		endIndex=Math.ceil((rightXvalue-funcXleft)/gridDist);
	}
	
	
	
	/*Following should not happen:	
	//if the indices are out of border
	if(leftXindex<0){leftXindex=0;}
	if(rightXindex>=allValues.length){rightXindex=allValues.length-1;}
	*/
		
	//values in the allvalues array between right and left xValue

		
	//values in the allvalues array between right and left xValue
	var newNumOfValues= Math.ceil((endIndex-startIndex)/step)+1;			
	var newValues = createArray(newNumOfValues,2);
			
	var index = startIndex;
	
	for(var i=0;i<newValues.length-1;i++){
		newValues[i][0]=allValues[index][0];
		newValues[i][1]=allValues[index][1];
		index += step;
	}
	
	newValues[newValues.length-1][0]= allValues[endIndex][0];		
	newValues[newValues.length-1][1]= allValues[endIndex][1];
	
	//Ausgaben
	/*
	console.log("startIndex:", startIndex, "endIndex", endIndex, "step", step);
	console.log("neNumOfValues",newNumOfValues);
	console.log("allValues",allValues);
	console.log("neNumOfValues",newNumOfValues);
	console.log("newValues",newValues);
	*/
	
	return newValues;
}
	/*function compareMethods(method1, method2, a, N,mu) {
		var values = new Array(6);
		var t_start1, t_end1, t_start2, t_end2;
		//take the time of the first variant and save it in values[0]
		t_start1 = new Date().getTime();
		var rek = method1(a, N, mu);
		t_end1 = new Date().getTime();
		values[0] = t_end1 - t_start1;

		//take the time of the second variant and save it in values[1]
		t_start2 = new Date().getTime();
		var it = method2(a, N, mu);
		t_end2 = new Date().getTime();
		values[1] = t_end2 - t_start2;

		//compute a difference-array and save it in values[2]
		var diff = createArray(rek.length, 2);
		for (var z = 0; z < diff.length; z++) {
			for (var s = 0; s < 2; s++) {
				if (s == 0)
					diff[z][s] = rek[z][1];
				if (s == 1) {
					diff[z][s] = rek[z][s] - it[z][s];
				}
			}
		}
		values[2] = diff;

		//sum the absolute values of the differences and save it in values[3]
		var sum = 0;
		for (var i = 0; i < diff.length; i++) {
			sum += Math.abs(diff[i][1]);
		}
		values[3] = sum;

		return values;
	}

	var values = compareMethods(iterativePointEvaluation, 
		iterativePointEvaluation2, d4, 5, 0);
		
	console.log("comparison of both methods: time of the first method:", 
		values[0], "time of the second method:", values[1], 
		"difference-vector of both methods:", values[2], 
		"sum of the absolute values of the difference:", values[3]);

	function runningTime(variant) {
		var t_start, t_end;
		t_start = new Date().getTime();
		console.log(d2);
		console.log(testCoeffs(d2, 5));
		console.log(coeffsToMatrix(d2));
		console.log(calculateIntegerPointValues(d2));
		console.log(iterativePointEvaluation(d2, 20, variant));
		t_end = new Date().getTime();
		console.log("at variant", variant, "running time", t_end - t_start);
	}*/

</script>
