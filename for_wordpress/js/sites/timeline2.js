/**
 *	This file contains the methods to build a timeline based on the database information
 *
 * 	Dependencies:
 * 	sql.js, vis.min.js, vis-timeline-graph2d.min.css, stringMethods.js
 */


/** builds a Timeline, based on the data of the database. 
 * The function is invoked in the  following function loadWaveletDBforTimeline(target) 
 * after loading the database.
 *
 *  (last modification: 02.05.17 Simon)
 * 
 *   @param{string[]} target - target of the timeline
 */
function buildTimeline(targets) {

	var types = db.exec("SELECT type,year,doi,description,logo,url FROM TYPES")[0].values;
	console.log('types',types);
	var waveletItems = [];
	//building all wavelet items with the information from the database
	for (var j = 0; j < types.length; j++) {
		var obj = {
			id : j,
			start : types[j][1] + '-06-01', //adding '-01-01' because in database we only save the year
			content : types[j][0],
			doi: types[j][2],
			description: types[j][3],
			logo: types[j][4],
			url : types[j][5],
			//type : 'box',
			//the content of the tooltip is generated by the following html-command
			//title : buildTooltipContent(types[j][0],types[j][3],types[j][4])

		};
		waveletItems.push(obj);
	}

	console.log(waveletItems);

	//creating the DataSet(part of vis.js) for the timeline
	var items = new vis.DataSet(waveletItems);

	// Configuration for the Timeline
	var options = {
		// specify a template for the items
		//template: template,

		//max and min zoom intervall as milliseconds
		zoomMin : 200000000000,
		zoomMax : 20000000000000,

		//max and min date
		max : '2100-06-01',
		min : '1900-06-01',
	};

	// Create the timeline
	var timeline = new vis.Timeline(document.getElementById(targets[0]), items, options);

	//add click-event to timeline
	timeline.on('click', function(properties) {

		 //if you click a item (not the background)
	  	 if (properties.what == "item") {
	  	 	updateTooltip(waveletItems[properties.item],properties.pageX,properties.pageY);
	   	}
	   	else{
	   		var tooltipEl = document.getElementById(targets[1]);
	   			//tooltipEl.style.left = 0;//x +'px';//pos.left + 'px';  //+ tooltipModel.caretX 
            	//tooltipEl.style.top = 0; //y + 'px';//pos.top + 'px';
	   			//tooltipEl.style.opacity = 0; 
	   			tooltipEl.style.visibility = 'hidden';
	   	}		     
	});
	
	
	function updateTooltip(dataset,x,y){
            // Tooltip Element
            var tooltipEl = document.getElementById(targets[1]);


            //update content
              console.log('dataset',dataset);
              tooltipEl.innerHTML = buildTooltipContent2(dataset.content, dataset.description, dataset.logo,dataset.doi,dataset.url);
  			
  			//update position
			//get absolute position of div-element (by jQuery method .offset())
			//var pos = $(document.getElementById(targets[0])).offset();
           
            //displays tooltip on hover
            
            //sets tooltip to right position tooltipModel.caretX gives right part of tooltip
            //var tooltipModel=chart.tooltip._model;
            //console.log("chart",chart);
            tooltipEl.style.left = x +'px';//pos.left + 'px';  //+ tooltipModel.caretX 
            tooltipEl.style.top = y + 'px';//pos.top + 'px';	//+ tooltipModel.caretY 
            tooltipEl.style.visibility = 'visible';
		};
}



/**
 *  Load the database named './wavelet_database.sqlite' (with calling a function ___,
 *  such that no additional waiting-tricks, like a timer, are needed).
 *  Moreover we build the timeline here.
 *  (last modification: 28.4.17 Simon)
 * 
 *   @param{string} target - name of target div.
 */

//not used anymore - but may be faster
function loadWaveletDBforTimeline(target) {
	//builds an HttpRequest on 'theUrl' and runs the 'callback' function with the content of the HttpRequest response
	function httpGetAsync(theUrl, callback) {
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.responseType = 'arraybuffer';

		xmlHttp.onreadystatechange = function() {
			//if the XMLHttpRequest was successful run the callback function with the response
			if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
				console.log("load database");
				callback(xmlHttp.response);
			} else {
				console.log("database could not be loaded");
			}
		};
		xmlHttp.open("GET", theUrl, true);
		// true bedeutet, dass onreadystate in neuem thread aufgerufen wird
		xmlHttp.send(null);
	}

	//constructs the callback function and runs the HttpRequest
	function start() {
		console.log("in start");
		var callback = function(str) {
			var uInt8Array = new Uint8Array(str);
			// do not use a 'var' here! So the database is saved as an global document. attribute
			db = new SQL.Database(uInt8Array);
			console.log("database loaded");
			//When the database is loaded, call the function "buildTimeline()".
			buildTimeline(target);
		};
		httpGetAsync('../../wavelet-systems.sqlite', callback);
	}

	start();
}
