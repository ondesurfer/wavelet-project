/**
 *	This file contains the methods to build a timeline based on the database information
 *
 * 	Dependencies:
 * 	sql.js, vis.min.js, vis-timeline-graph2d.min.css
 */


/** builds a Timeline, based on the data of the database. 
 * The function is invoked in the  following function loadWaveletDBforTimeline(target) 
 * after loading the database.
 *
 *  (last modification: 02.05.17 Simon)
 * 
 *   @param{string} target - target of the timeline
 */
function buildTimeline(target) {

	var types = db.exec("SELECT type,year,description,logo,url FROM TYPES")[0].values;

	var waveletItems = [];
	//building all wavelet items with the information from the database
	for (var j = 0; j < types.length; j++) {
		var obj = {
			//id is nessasary to acess the right item when it is clicked
			id : j,
			start : types[j][1] + '-06-01', //adding '-01-01' because in database we only save the year
			content : types[j][0],
			type : 'box',
			url : types[j][4],
			//the content of the tooltip is generated by the following html-command
			title : "<h2>" + types[j][0] + "</h2>" + splitter(types[j][2], 30) + "<p ><img src='" + types[j][3] + "' width='100' max-height='50'></p>"

		};
		waveletItems.push(obj);
	}

	//console.log(waveletItems);

	//creating the DataSet(part of vis.js) for the timeline
	var items = new vis.DataSet(waveletItems);

	// Configuration for the Timeline
	var options = {
		// specify a template for the items
		//template: template,

		//max and min zoom intervall as milliseconds
		zoomMin : 200000000000,
		zoomMax : 20000000000000,

		//max and min date
		max : '2100-06-01',
		min : '1900-06-01',
		tooltip : {
			followMouse : true,
			overflowMethod : 'cap'
		}
	};

	// Create the timeline
	var timeline = new vis.Timeline(document.getElementById(target), items, options);

	//ad click-event to timeline
	timeline.on('click', function(properties) {
		//if you click a item (not the background)
		if (properties.what == "item") {
			
			//console.log(waveletItems[properties.item].url);
			document.location.href = waveletItems[properties.item].url;
		}
	});
}



/**
 *  Load the database named './wavelet_database.sqlite' (with calling a function ___,
 *  such that no additional waiting-tricks, like a timer, are needed).
 *  Moreover we build the timeline here.
 *  (last modification: 28.4.17 Simon)
 * 
 *   @param{string} target - name of target div.
 */

//not used anymore - but may be faster
function loadWaveletDBforTimeline(target) {
	//builds an HttpRequest on 'theUrl' and runs the 'callback' function with the content of the HttpRequest response
	function httpGetAsync(theUrl, callback) {
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.responseType = 'arraybuffer';

		xmlHttp.onreadystatechange = function() {
			//if the XMLHttpRequest was successful run the callback function with the response
			if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
				console.log("load database");
				callback(xmlHttp.response);
			} else {
				console.log("database could not be loaded");
			}
		};
		xmlHttp.open("GET", theUrl, true);
		// true bedeutet, dass onreadystate in neuem thread aufgerufen wird
		xmlHttp.send(null);
	}

	//constructs the callback function and runs the HttpRequest
	function start() {
		console.log("in start");
		var callback = function(str) {
			var uInt8Array = new Uint8Array(str);
			// do not use a 'var' here! So the database is saved as an global document. attribute
			db = new SQL.Database(uInt8Array);
			console.log("database loaded");
			//When the database is loaded, call the function "buildTimeline()".
			buildTimeline(target);
		};
		httpGetAsync('../../wavelet-systems.sqlite', callback);
	}

	start();
}

/** Adds html-tags to a string. After a maximum 'num' chars a new paragraph is added.
 * If a html-tag is already in the input-string, we do not change the input string. 
 *
 * 
 *   @param{string} str - text which we want to split into paragraphs
 *   @param{int} num - maximum number of chars, which belong to one paragraph
 * 
 *   @return{int} str - output string
 */
function splitter(str, num) {
	var marker2 = 0;
	var marker1 = 0;

	if (str.indexOf("</") != -1) {
		console.log("Seems as the string already contains html-tags, do not add more html-tags for paragraphs");
		return str;
	}

	while (marker1 < str.length) {
		marker1 = marker2;

		for ( marker2 = marker2 + num; marker2 > marker1; marker2--) {
			//if marker2 is at the end - so the full text is parsed
			if (marker2 == str.length) {
				str = [str.slice(0, marker1), "<p>", str.slice(marker1)].join('');
				marker2 = marker2 + 3;
				str = [str.slice(0, marker2), "</p>", str.slice(marker2)].join('');
				marker2 = marker2 + 4;
				return str;
			}
			//if an space to seperate the text is found
			if (str.charAt(marker2) == " ") {
				str = [str.slice(0, marker1), "<p>", str.slice(marker1)].join('');
				marker2 = marker2 + 3;
				str = [str.slice(0, marker2), "</p>", str.slice(marker2)].join('');
				marker2 = marker2 + 4;
				break;
			}
			//if no space is found to seperate the text
			if (marker2 == marker1 + 1) {
				console.log("a word is longer than " + num + " charakters");
				return str;
			}
		}
	}
}