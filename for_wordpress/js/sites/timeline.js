/**
 *	This file contains the methods to build a timeline based on the database information
 *
 * 	Dependencies:
 * 	sql.js, vis.min.js, vis-timeline-graph2d.min.css
 */


/** builds a Timeline, based on the data of the database. 
 * The function is invoked in the  following function loadWaveletDBforTimeline(target) 
 * after loading the database.
 *
 *  (last modification: 02.05.17 Simon)
 * 
 *   @param{string} target - target of the timeline
 */
function buildTimeline(targets) {

	var types = db.exec("SELECT type,year,doi,description,logo,url FROM TYPES")[0].values;

	var waveletItems = [];
	//building all wavelet items with the information from the database
	for (var j = 0; j < types.length; j++) {
		var obj = {
			//id is nessasary to acess the right item when it is clicked
			id : j,
			start : types[j][1] + '-06-01', //adding '-01-01' because in database we only save the year
			content : types[j][0],
			doi: types[j][2],
			type : 'box',
			url : types[j][5],
			//the content of the tooltip is generated by the following html-command
			title : buildTooltipContent(types[j][0],types[j][3],types[j][4])

		};
		waveletItems.push(obj);
	}

	//console.log(waveletItems);

	//creating the DataSet(part of vis.js) for the timeline
	var items = new vis.DataSet(waveletItems);

	// Configuration for the Timeline
	var options = {
		// specify a template for the items
		//template: template,

		//max and min zoom intervall as milliseconds
		zoomMin : 200000000000,
		zoomMax : 20000000000000,

		//max and min date
		max : '2100-06-01',
		min : '1900-06-01',
		tooltip : {
			followMouse : true,
			overflowMethod : 'cap'
		}
	};

	// Create the timeline
	var timeline = new vis.Timeline(document.getElementById(targets[0]), items, options);

	//ad click-event to timeline
	timeline.on('click', function(properties) {
		//if you click a item (not the background)
		if (properties.what == "item") {
			
			//console.log(waveletItems[properties.item].url);
			document.location.href = waveletItems[properties.item].url;
		}
	});
	
	//if a second target for the reference link is given
	if(targets.length==2){
		timeline.on('itemover', function(properties) {	
				//console.log(waveletItems[properties.item].doi);
				//console.log(targets[1]);
				var name=waveletItems[properties.item].content;
				var doi=waveletItems[properties.item].doi;
				document.getElementById(targets[1]).innerHTML = buildReferenceLink(name,doi);
		});
	}
}

/**
 *  builds a html-string to build the tooltip content for the timeline
 *  (last modification: 17.5.17 Simon)
 * 
 *  @param{String} name - name of the wavelet-system-type
 *  @param{String} description - description for the tooltip
 *  @param{String} picLink - Link where to load the logo from
 */
function buildTooltipContent(name, description, picLink){
	var htmlString = "<h3>" + name + "</h3>" ;	
	if(description!=undefined){
		htmlString += splitter(description, 30);
	}
			 
	if(picLink!=undefined){
		htmlString += "<p ><img src='" + picLink + "' width='100' max-height='50'>" + "</p>";
	}
	return htmlString;		 
}


/**
 *  builds a html-string to place a link of a doi in a div in the html-page
 *  (last modification: 17.5.17 Simon)
 * 
 *  @param{string} name - name of the wavelet-system-type
 *  @param{doi} doi - doi of the reference (can also be a link)
 */

function buildReferenceLink(name, doi){
	console.log("doi",doi);
	if(doi==undefined){
		console.log("No link available.");
		return " ";
	}
	
	
	var link = doi; //if no link is given, the link stays empty
	
	//if the link is link starting with 'www.'
	if(doi.startsWith("www.")){
		link = "http://"+doi;		
	}

	//if link is an DOI we add a adress to open - else nothing is done, we just hope it is a valid url
	if(doi.startsWith("10")){
		link = "http://www.dx.doi.org/"+doi;		
	}
	
	var htmlString = "<p> Reference of "+name+": " + "<a href='"+link+"' >"+link+ "</a>"; 
	return htmlString;
}


/**
 *  Load the database named './wavelet_database.sqlite' (with calling a function ___,
 *  such that no additional waiting-tricks, like a timer, are needed).
 *  Moreover we build the timeline here.
 *  (last modification: 28.4.17 Simon)
 * 
 *   @param{string} target - name of target div.
 */

//not used anymore - but may be faster
function loadWaveletDBforTimeline(target) {
	//builds an HttpRequest on 'theUrl' and runs the 'callback' function with the content of the HttpRequest response
	function httpGetAsync(theUrl, callback) {
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.responseType = 'arraybuffer';

		xmlHttp.onreadystatechange = function() {
			//if the XMLHttpRequest was successful run the callback function with the response
			if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
				console.log("load database");
				callback(xmlHttp.response);
			} else {
				console.log("database could not be loaded");
			}
		};
		xmlHttp.open("GET", theUrl, true);
		// true bedeutet, dass onreadystate in neuem thread aufgerufen wird
		xmlHttp.send(null);
	}

	//constructs the callback function and runs the HttpRequest
	function start() {
		console.log("in start");
		var callback = function(str) {
			var uInt8Array = new Uint8Array(str);
			// do not use a 'var' here! So the database is saved as an global document. attribute
			db = new SQL.Database(uInt8Array);
			console.log("database loaded");
			//When the database is loaded, call the function "buildTimeline()".
			buildTimeline(target);
		};
		httpGetAsync('../../wavelet-systems.sqlite', callback);
	}

	start();
}

/** Adds html-tags to a string. After a maximum 'num' chars a new paragraph is added.
 * If a html-tag is already in the input-string, we do not change the input string. 
 *
 * 
 *   @param{string} str - text which we want to split into paragraphs
 *   @param{int} num - maximum number of chars, which belong to one paragraph
 * 
 *   @return{int} str - output string
 */

function splitter(str, num) {
	var marker2 = 0;
	var marker1 = 0;
	
	if(str==""){return str;};

	if (str.indexOf("</") != -1) {
		console.log("Seems as the string already contains html-tags, do not add more html-tags for paragraphs");
		return str;
	}

	while (marker1 < str.length) {
		marker1 = marker2;

		for ( marker2 = marker2 + num; marker2 > marker1; marker2--) {
			//if marker2 is at the end - so the full text is parsed
			if (marker2 == str.length) {
				str = [str.slice(0, marker1), "<p>", str.slice(marker1)].join('');
				marker2 = marker2 + 3;
				str = [str.slice(0, marker2), "</p>", str.slice(marker2)].join('');
				marker2 = marker2 + 4;
				return str;
			}
			//if an space to seperate the text is found
			if (str.charAt(marker2) == " ") {
				str = [str.slice(0, marker1), "<p>", str.slice(marker1)].join('');
				marker2 = marker2 + 3;
				str = [str.slice(0, marker2), "</p>", str.slice(marker2)].join('');
				marker2 = marker2 + 4;
				break;
			}
			//if no space is found to seperate the text
			if (marker2 == marker1 + 1) {
				console.log("a word is longer than " + num + " charakters");
				return str;
			}
		}
	}
}