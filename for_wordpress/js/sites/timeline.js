/**
 *	This file contains the methods to build a timeline based on the database information
 *
 * 	Dependencies:
 * 	sql.js, vis.min.js, vis-timeline-graph2d.min.css, stringMethods.js
 */


/** builds a Timeline, based on the data of the database. 
 * The function is invoked in the  following function loadWaveletDBforTimeline(target) 
 * after loading the database.
 *
 *  (last modification: 02.05.17 Simon)
 * 
 *   @param{string} target - target of the timeline
 */
function buildTimeline(targets) {

	var types = db.exec("SELECT type,year,doi,description,logo,url FROM TYPES")[0].values;

	var waveletItems = [];
	//building all wavelet items with the information from the database
	for (var j = 0; j < types.length; j++) {
		var obj = {
			//id is nessasary to acess the right item when it is clicked
			id : j,
			start : types[j][1] + '-06-01', //adding '-01-01' because in database we only save the year
			content : types[j][0],
			doi: types[j][2],
			type : 'box',
			url : types[j][5],
			//the content of the tooltip is generated by the following html-command
			title : buildTooltipContent(types[j][0],types[j][3],types[j][4])

		};
		waveletItems.push(obj);
	}

	//console.log(waveletItems);

	//creating the DataSet(part of vis.js) for the timeline
	var items = new vis.DataSet(waveletItems);

	// Configuration for the Timeline
	var options = {
		// specify a template for the items
		//template: template,

		//max and min zoom intervall as milliseconds
		zoomMin : 200000000000,
		zoomMax : 20000000000000,

		//max and min date
		max : '2100-06-01',
		min : '1900-06-01',
		tooltip : {
			followMouse : true,
			overflowMethod : 'cap'
		}
	};

	// Create the timeline
	var timeline = new vis.Timeline(document.getElementById(targets[0]), items, options);

	//ad click-event to timeline
	timeline.on('click', function(properties) {
		//if you click a item (not the background)
		if (properties.what == "item") {
			
			//console.log(waveletItems[properties.item].url);
			document.location.href = waveletItems[properties.item].url;
		}
	});
	
	//if a second target for the reference link is given
	if(targets.length==2){
		timeline.on('itemover', function(properties) {	
				//console.log(waveletItems[properties.item].doi);
				//console.log(targets[1]);
				var name=waveletItems[properties.item].content;
				var doi=waveletItems[properties.item].doi;
				document.getElementById(targets[1]).innerHTML = buildReferenceLink(name,doi);
		});
	}
}



/**
 *  Load the database named './wavelet_database.sqlite' (with calling a function ___,
 *  such that no additional waiting-tricks, like a timer, are needed).
 *  Moreover we build the timeline here.
 *  (last modification: 28.4.17 Simon)
 * 
 *   @param{string} target - name of target div.
 */

//not used anymore - but may be faster
function loadWaveletDBforTimeline(target) {
	//builds an HttpRequest on 'theUrl' and runs the 'callback' function with the content of the HttpRequest response
	function httpGetAsync(theUrl, callback) {
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.responseType = 'arraybuffer';

		xmlHttp.onreadystatechange = function() {
			//if the XMLHttpRequest was successful run the callback function with the response
			if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
				console.log("load database");
				callback(xmlHttp.response);
			} else {
				console.log("database could not be loaded");
			}
		};
		xmlHttp.open("GET", theUrl, true);
		// true bedeutet, dass onreadystate in neuem thread aufgerufen wird
		xmlHttp.send(null);
	}

	//constructs the callback function and runs the HttpRequest
	function start() {
		console.log("in start");
		var callback = function(str) {
			var uInt8Array = new Uint8Array(str);
			// do not use a 'var' here! So the database is saved as an global document. attribute
			db = new SQL.Database(uInt8Array);
			console.log("database loaded");
			//When the database is loaded, call the function "buildTimeline()".
			buildTimeline(target);
		};
		httpGetAsync('../../wavelet-systems.sqlite', callback);
	}

	start();
}
