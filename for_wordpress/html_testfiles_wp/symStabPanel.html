<!DOCTYPE HTML>

<head>
	<title>Timeline | Templates</title>

	<script src="../js/ext_libs/sql.js"></script>
	<script src="../js/sites/timeline.js"></script>
	<script src="../js/ext_libs/timeline_dist/vis.min.js"></script>
	<script src="../js/ext_libs/jquery-3.1.0.min.js"></script>
	<script src="../js/libs/dbMethods.js"></script>
	<script src="../js/ext_libs/Chart2.6.0.min.js"></script>


	<!-- load extern stylesheet-->
	<!--<link href="../js/ext_libs/timeline_dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" /> -->

	

</head>

<body>
	
	<div class="chart-container" style="position: relative; height:40vh; width:80vw">
    <canvas id="canvasChart"></canvas>
</div>
</body>

	
	<!--modify style of timeline-->
<style type="text/css">
	
</style>
	
<script type="text/javascript">
	
	checkDB('wavelet-systems.sqlite', buildSymStabChart, ["canvasChart"]);
	
	
	function buildSymStabChart(targets){
		var types = db.exec("SELECT type,doi,symmetry,stability,logo,url FROM TYPES")[0].values;
		console.log(types);
	
		//all possible symmetrie types
		var syms = findProps(types,2);
		//all possible stability types
		var stabs = findProps(types,3);
		
		var color = Math.round(255/types.length);
		
		var waveletItems = [];
		//building all wavelet items with the information from the database
		for (var j = 0; j < types.length; j++) {
			console.log(255-j*color);
			console.log("rgba(" + (j*color) + "," + (255-j*color) +","+ 0 + ",0.5)");
			var obj = {
				//id is nessasary to acess the right item when it is clicked
				id : j,
				label: types[j][0],
				doi: types[j][1],
				url : types[j][5],
				backgroundColor: "rgba(" + (j*color) +","+ (255-j*color) +","+ 0 + ",0.5)",
		        borderColor: "rgba(" + (j*color) +","+ (255-j*color) +","+ 0 + ",1)",
		       	data: getItemPosition(j),
				//the content of the tooltip is generated by the following html-command
				//title : buildTooltipContent(types[j][0],types[j][3],types[j][4])
	
			};
			waveletItems.push(obj);
		}
		var data4 = {datasets: waveletItems};	
				
		console.log("stabs",stabs);
		console.log("syms",syms);
		  
		
		function getItemPosition(id){
		 var data = [{
	        	x: stabs.indexOf(types[id][3]),
	          	y: syms.indexOf(types[id][2]),
	           	r: 15
		    	}];
	   return data;
		}
		
		  
		//building chart
		var chart = new Chart(document.getElementById(targets[0]), {
		    type: 'bubble',
		    data: data4,
		    options:{
		    	responsive: true,
		      	title: {
		        	display: true,
		        	text: 'Wavelet-Systems'
		      	},
		      	scales: {
		        	yAxes: [{ 
		          		scaleLabel: {
		            		display: true,
		            		labelString: "Symmetry"
		          		},
		          		ticks: {
	                    	// overwrite axis numbers
	                    	callback: function(value, index, values) {
	                        	return syms[value];
	                    		}
	                  	}
		        	}],
		        	xAxes: [{ 
		          		scaleLabel: {
		            		display: true,
		            		labelString: "Stability"
		          		},
		           		ticks: {
	                    	// Include a dollar sign in the ticks
	                    	callback: function(value, index, values) {
	                    		return stabs[value];
	                    	}
	                  	}
		        	}]
		      	},
		    	layout: {
	        		padding: {
	                	left: 50,
	                	right: 50,
	                	top: 50,
	                	bottom: 50
	            	}
	       		},
	       		tooltips:{
	       			callbacks: {
	                	labelColor: function(tooltipItem, chart) {
	                    	return {
	                        	borderColor: 'rgb(255, 0, 0)',
	                        	backgroundColor: 'rgb(255, 0, 0)'
	                    	};
	                    }
	                }
	       		}//,
		    }
		});
		
	/*Chart.plugins.register({
	  afterDatasetsDraw: function(chartInstance, easing) {
	    // To only draw at the end of animation, check for easing === 1
	    
	    var ctx = chartInstance.chart.ctx;
	    chartInstance.data.datasets.forEach(function (dataset, i) {
	      var meta = chartInstance.getDatasetMeta(i);
	      console.log("meta",meta);
	      if (!meta.hidden) {
	        meta.data.forEach(function(element, index) {
	          // Draw the text in black, with the specified font
	          ctx.fillStyle = 'rgb(0, 0, 0)';
	          var fontSize = 16;
	          var fontStyle = 'normal';
	          var fontFamily = 'Helvetica Neue';
	          ctx.font = Chart.helpers.fontString(fontSize, fontStyle, fontFamily);
	          // Just naively convert to string for now
	          // <---- ADJUST TO DESIRED TEXT --->
	          var dataString = chart.data.datasets[index].label;
	          console.log(index);
	          console.log("dataset.data",chart.data.datasets[index].label);
	          //var dataString = "Daub";
	          // Make sure alignment settings are correct
	          ctx.textAlign = 'center';
	          ctx.textBaseline = 'middle';
	          var padding = 5;
	          var position = element.tooltipPosition();
	          ctx.fillText(dataString, position.x, position.y - (fontSize / 2) - padding);
	        });
	      }
	    });
	  }
	  
	});*/
		
		document.getElementById('canvasChart').onclick = function(evt){
			console.log("evt",evt);
	
		     var index = chart.lastActive[0]._datasetIndex;
		   	console.log(index);
		  	
		  	 if (index !== undefined) {
	        	var dataset = chart.data.datasets[index];
	         	document.location.href = dataset.url;
	       	}
	       	//console.log("dataset",dataset);
	       	//console.log("title",title);
	       	
		     
		};
	}
	
	function findProps(types,prop){
		var syms=[];
		for (var j = 0; j < types.length; j++) {
			var sym = types[j][prop];
			if (syms.indexOf(sym)== -1){
				syms.push(sym);
			}
		}
			return syms;
	}
	
</script>
