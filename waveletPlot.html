<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<!-- Date: 2016-04-26 -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Wavelet Plot</title>
		<meta name="author" content="Simon" />
		<meta name="author" content="Andreas" />
		<!--include scripts and libraries-->
		<script src="d3.js"></script>
		<script src="mask.js"></script>
		<script src="math.js"></script>
		<script src="math2.js"></script>
		<script src="matrixOperations.js"></script>
		<script src="pointEvaluation.js"></script>
		<script src="function-plot.js"></script>
		<script src="numeric-1.2.6.js"></script>
		<script src="gauss2.js"></script>

		<style>
			input[type=text] {
				width: 300px;
			}
			input {
				padding: 6px;
			}
			body, html, input {
				font-family: sans-serif;
				font-size: 11pt;
			}
			daub_field {
				margin: 20px 0;
			}
		</style>
	</head>
	<body>
		
		<select id="selection1" size="5"> 
    	 	<option value="1">Box Function</option> 
    	 	<option value="9">Hat Function</option> 
    	 	<option value ="10">Quadratic B-Spline</option> 
    	 	<option value="DG" selected>Daubechies-2N-Generator</option>  
    	 </select>
    	 
    	 <form id="mu_field">
			<label for="eq1">Enter Derivation Order:</label>
			<input type="text" id="eq1" value="0" />
			<input type="submit" value="Draw" />
		</form>		
	
		<form id="daub_field">
			<label for="eq">Enter Daubechies Number N:</label>
			<input type="text" id="eq" value="3" />
		</form>
		
		<div id="plot"></div>
		
		<p>
			Plot library:
			<a href="https://github.com/maurizzzio/function-plot">
				https://github.com/maurizzzio/function-plot
			</a>
		</p>

		<script>
			//Wavelet-coefficients (from wikipedia):
			var a = new Array();
			//Coefficients of the box function
			//a[1]=[1,1];
			
			//Einfachste Maske eines dualen Generators
			//allerdings nicht stetig...
			//a[1]=[-1/4, 1/2, 3/2, 1/2, -1/4];
			
			//CDF(2,4)-Generator
			// a[1]=[3/64, -3/32, -1/4, 19/32, 45/32, 19/32,
			// -1/4, -3/32, 3/64];
			
			a[1] = [1,1];
			
			a[2] = [(1 + Math.sqrt(3)) / 4, ((3 + Math.sqrt(3)) / 4), 
				(3 - Math.sqrt(3)) / 4, (1 - Math.sqrt(3)) / 4];
			a[3] = [0.47046721, 1.14111692, 0.650365, -0.19093442, 
				-0.12083221, 0.0498175];

			//it seems that a[4] is a little bit wrong!
			a[4] = [0.32580343, 1.01094572, 0.8922014, -0.03967503, 
				-0.26450717, 0.0436163, 0.0465036, -0.01498699];
			a[5] = [0.22641898, 0.85394354, 1.02432694, 0.19576696, 
				-0.34265671, -0.04560113, 0.10970265, -0.0088268, -0.01779187, 
					0.0047174279];
			a[6] = [0.1577424300000, 0.6995038100000, 1.0622637600000, 
				0.4458313200000, -0.3199866000000, -0.1835180600000, 
				0.1378880900000, 0.0389232100000, -0.0446637500000, 
				0.0007832511520, 0.0067560623600, -0.0015235338100];

			a[7] = [0.1100994300000, 0.5607912800000, 1.0311484900000, 
				0.6643724800000, -0.2035138200000, -0.3168350100000, 
				0.1008467000000, 0.1140034500000, -0.0537824500000, 
				-0.0234399400000, 0.0177497900000, 0.0006075149950, 
				-0.0025479047200, 0.0005002268530];

			a[8] = [0.0769556200000, 0.4424672500000, 0.9554861500000, 
				0.8278165300000, -0.0223857400000, -0.4016586300000, 
				0.0006681940920, 0.1820763600000, -0.0245639000000, 
				-0.0623502100000, 0.0197721600000, 0.0123688400000, 
				-0.0068877192600, -0.0005540045490, 0.0009552297110, 
				-0.0001661372610];
				
			//Coefficients of the hat function
			a[9]=[0.5,1,0.5];
			
			//Quadratic B-Spline
			a[10]=[0.25,0.75,0.75,0.25];
			
			//CDF(1,3)-Generator
			a[11] = [-1/8, 1/8, 1, 1, 1/8, -1/8];
			
			//Coefficients of the box function
			//bf = [1, 1];
			
			//Coefficients of the hat function
			//hf = [1, 1/2, 1];
			
			//save the following globally:
			//    c			the temporary used refinement-coefficients
			//    values 	the corresponding computed wavelet values
			//	  N_max		the maximal 1/2^N-step-size of the x-lattice
			//	  N_0		the 1/2^N-step-size for iteration
			//	  M			the number of equidistant x-lattice-points in the
 			//				plot-area
 			//	  plot		the plot instance
			var c;
			var mu;
			var values;
			var N_0 = 14;
			var N_max = 17;
			var M = 300;
			var plotInstance;
			var type_nr=document.getElementById('selection1').value;
			//sollten den plot loeschen, wenn sich das global aendert.
			
			function draw() {
				
					try
					 { 
						var type_nr = document.getElementById('selection1').value;
						mu = parseInt(document.getElementById('eq1').value);
						
						//Extra-request for Daubechies-wavelets
						if(type_nr == "DG"){
							c = a[document.getElementById('eq').value];	
						}
						else{
							c = a[type_nr];
						}
						
						if (!testRefCoeffs(c, 3)) {
							alert("invalid coefficients");
						} else{ 
							console.log("Derivative order: " + mu);
							console.log("Coefficients: " + c);
						
							values = iterativePointEvaluation2(c, N_0, mu);
							console.log("values",values);
						
							var plotInst = functionPlot({
								target : '#plot',
								data : [{
								points : filter(-100,+100,values,700),
								fnType : 'points',
								graphType : 'polyline',
								}]
							});
				
						//return the wavelet plot as object
						return plotInst;
					}
				}
				catch (err) {
					console.log(err);
					alert(err);
				}
			}
			
			//add the selection of the function to plot
			document.getElementById('selection1').onchange = function(event) {
				event.preventDefault();
				type_nr = document.getElementById('selection1').value;
				// var daub_field2 = document.getElementById('daub_field2');
				if(type_nr == "DG"){
					 daub_field.style.visibility = "visible";
				}
				else{
					daub_field.style.visibility = "hidden";
				}
			};
			
			//add the draw-function to the draw-button
			document.getElementById('mu_field').onsubmit = function(event) {
				event.preventDefault();
				//draw once and save the graph as object
				plotInstance = draw();
				
				//attach the funtion filter-zoom as listener to the zoom-event 				
				plotInstance.on("during:draw", zoomFilter);
				
			};
			
			//must be invoked by a FunctionPlot object!
			function zoomFilter(){
				var xDomain=this.options.xDomain;	
				var newPoints=filter(xDomain[0],xDomain[1],values,700);
		
				
				if(newPoints==undefined){
					alert("No more detailled points available. Please zoom out.");
				}else{		
        			this.options.data[0].points= newPoints;
        			console.log("newPoints",newPoints);
        		}  		
   			}
			
			


			function zoomAdaption() {
				//"this" has to be an instance of functionPlot
				//xDomain : domain of the x-values ,
				//points: the used points from the previous plot
				var xDomain = this.options.xDomain;

				//compute the new values... 
				//!!!Attention!!! take care of the x-boundery-values
				//before zooming
				var N = getN(xDomain[0], xDomain[1], M);
				
				if(N > N_max){
					console.log("from this level onwards the results become incorrect");
					//plot.options.disableZoom = true;
				}
				else{
					//plot.options.disableZoom = false;
					var result = recursivePointEvaluation2(c, xDomain[0],
						xDomain[1], values, N);
					//...and save globally:
					values = result[0];
					//console.log("the new values:", result[1]);
					//values=[[1,1],[2,1],[3,1],[4,1]];
					//give the new values to the plot-object:
					this.options.data[0].points = result[1];
				}
			}
			
			// document.getElementById('daub_field').onsubmit = function (event) {
	    		// event.preventDefault();
	    		// draw();
	   		// };
		
		</script>
	</body>
</html>

